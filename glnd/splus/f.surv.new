f.surv.new <- function(time,status,group=rep(1,length(time)),
 event="Event",event.xlab=event,tit=NULL,grp.abbr=NULL,
 xat=round(seq(min(time),max(time),length=6)[-1]),
 xby=(xat[2]-xat[1])/4,
 xdisp.at=xat,
 pcex=1.1,
 abbr.paste=T,
 ylim=c(0,1),
 yby=diff(ylim)/10,
 xlim=c(0,max(time)),
 file=NULL,pagex=NULL,figx=NULL,
 datex=T,pvalue=T,percent=T,
 lty=1:length(table(group)),lwd=2,
 subset=ifelse(is.na(time),TRUE,
  !(ifelse(time==0,time+0.000001,time)<= xlim[1] & status==1)),
 subset.name="",
 ylab="Months after Randomization",
 position=c(0+max(time,na.rm=T)/20,mean(ylim),quantile(time,0.50,na.rm=T),3))
{ 
print(lty)
print(position)
if(is.null(tit)) {tit <- "" # attr(group,"label")
if(!all(subset)) tit <- paste(subset.name, " Patients",". ",tit,sep="")}
# make default lines as many as group levels same with lwd
# make defalt "pretty" xby and xat and yby
# allow for na group as in surv.plot
# allign numbers alonf the slash in the bottom display of the plot
# add subset.name with proper pasting to the title
if (event=="death" | event=="Death" |
 event=="dead" | event=="Dead") event <- "death"
xaxs <- "i"
subset <- subset & !is.na(group) & !is.na(time) & !is.na(status)
time <- time[subset]
status <- status[subset]
group.attributes <- attributes(group)
group <- group[subset]
attributes(group) <- group.attributes
group.names <- names(table(group))
group.abbr <- if(is.null(grp.abbr)) substring(group.names,1,1) else grp.abbr
names(group.abbr) <- group.names
if(any(table(group)==0)) {
aaa.tmp <- group.names[table(group)!=0]
group <- f.code(group,label=attr(group,"label"),levels=aaa.tmp,
 labels=aaa.tmp)
group.names <- names(table(group))
group.abbr <- if(is.null(grp.abbr)) substring(group.names,1,1) else grp.abbr
names(group.abbr) <- group.names
}

# group.names.legend <- group.names
#for(i in 1:length(group.names)) {
#if(nchar(group.names[i])>8) group.names.legend[i] <- paste(group.names[i],
# " ",group.abbr[i])
#print(group.names.legend[i])
#}

group.names.legend <- if(max(nchar(group.names))>8) 
  paste(group.names, "  (",group.abbr,")",sep="") else group.names

# *** need to eliminate empty levels

# censoring observations at max time
status[time > xlim[2]] <- 0
time[time > xlim[2]] <- xlim[2]

# setup of the size of the plot
par(mfrow=c(1,1),mar=c(10,5,3,3),oma=c(22,2,2,2),cex=1.0)

d <- survfit(Surv(time,status)~group)

f.plot.survfit(d,conf.int=F,lty=lty,lwd=lwd,cex=pcex,xaxs=xaxs, 
  mark.time=F,xlim=xlim,ylim=ylim,xlab="",ylab="",xaxt="n",yaxt="n")

axis(side=1,at=c(min(xlim),seq(0,xlim[2],by=xby)),
 labels=rep(" ",2+floor(xlim[2]/xby)))
mtext(text=paste(c(min(xlim),xat)),side=1,line=0.5,at=c(min(xlim),xat),cex=pcex)

if(percent) {
axis(side=2,at=seq(ceiling(ylim[1]*10)/10,ylim[2],by=yby),
 labels=f.round(100*seq(ceiling(ylim[1]*10)/10,ylim[2],by=yby)),
 srt=0,adj=0.8,cex=pcex) } else {
axis(side=2,at=seq(ceiling(ylim[1]*10)/10,ylim[2],by=yby),
 labels=f.round(seq(ceiling(ylim[1]*10)/10,ylim[2],by=yby),2),
 srt=0,adj=0.8,cex=pcex)
}

if(is.null(tit)) tit <- ""
mtext(tit, side=3,line=1)

if(percent) {
mtext(text=if(event=="death") "Percent Surviving" else 
 paste("Percent Free from",paste(event,collapse=" ")),
 side=2,line=3,cex=pcex) } else {
mtext(text=if(event=="death") "Proportion Surviving" else 
 paste("Proportion Free from",paste(event,collapse=" ")),
 side=2,line=3.5,cex=pcex) 
}

if(length(group.names)>=2) {
legend(c(position[1],position[1]),c(position[2],position[2]),
 legend=group.names.legend,
 lty=lty,lwd=lwd,bty="n")
d.diff <- surv.diff(time=time,status=status,group=group)
if(pvalue) {
pvalue <- 
 f.round.pvalue(1-pchisq(d.diff$chisq,length(group.names)-1),tex=F)$rpvalue
mtext(text=pvalue,side=1,line=-position[4],at=position[3],cex=1.2,adj=0)
}
}

if(!is.null(file)) {
out <- list()
for(k in group.names) 
 out[[k]] <- stepfun(c(0,d$time[d$strata%==%k]),c(1,d$surv[d$strata%==%k]))
write(format(t(cbind(out$grp1$x,out$grp1$y))),ncol=2,
 file=paste(file,"grp1",sep="."))
write(format(t(cbind(out$grp2$x,out$grp2$y))),ncol=2,
 file=paste(file,"grp2",sep="."))
}

mtext(ylab,side=1,line=2,cex=pcex)
par(cex=0.95)
ns.dist <- 1.3

if(percent) {
mtext(text=paste("No. of Patients / ", 
 if(event=="death") "Percent Surviving" else 
 paste("Percent Free from",paste(event.xlab,collapse=" ")),sep=""),
 side=1,line=3.7,at=min(xlim),adj=0) } else {
mtext(text=paste("No. of Patients / ", 
 if(event=="death") "Proportion Surviving" else 
 paste("Proportion Free from",paste(event.xlab,collapse=" ")),sep=""),
 side=1,line=3.7,at=min(xlim),adj=0)
}

at.risk <- list()
surv.prob <- list()
#------------
if(length(group.names)==1) d$strata <- group[1:length(d$surv)]
print(group.names)
print("ok")
line.count <- 4
for(k in group.names) {
 at.risk[[k]] <- d$n.risk[d$strata%==%k][1]
 for(i in xdisp.at) at.risk[[k]] <- c(at.risk[[k]],d$n.risk[d$strata%==%k][
  d$time[d$strata%==%k] >= i][1])
 surv.prob[[k]] <- NULL
 for(i in xdisp.at)  {
  tmp.surv <- rev(d$surv[d$strata%==%k][d$time[d$strata%==%k]<= i])[1]
  surv.prob[[k]] <- c(surv.prob[[k]],ifelse(is.na(tmp.surv),1,tmp.surv))
  }
print(k)
print(surv.prob[[k]])
#------------
line.count <- line.count+1
if(percent) {
aaa <- paste(at.risk[[k]][-1],"/",ifelse(round(100*surv.prob[[k]],1)==100,
 "100",f.round(100*surv.prob[[k]],1)),sep="") } else {
aaa <- paste(at.risk[[k]][-1],"/",ifelse(round(100*surv.prob[[k]],1)==100,
 "100",f.round(surv.prob[[k]],2)),sep="")
}
aaa <- ifelse(is.na(at.risk[[k]][-1]),"",aaa)
mtext(aaa,side=1,line=line.count,at=xdisp.at)
mtext(paste(at.risk[[k]][1]),side=1,line=line.count,at=min(xlim),adj=0)
if(length(group.names)>=2) {
 if(max(nchar(group.names))>8) {
   mtext(paste(group.abbr[k],"    ",sep=""),
   side=1,line=line.count, at=xlim[1],adj=1)} else {
  mtext(paste(k,"  ",sep=""),side=1,line=line.count, at=xlim[1],adj=1) }
}
}
if(datex) {
datex.line <- line.count+11-(length(group.names))+2
mtext(date(),side=1,line=datex.line,at=xlim[2],adj=1,outer=T)
if(!is.null(pagex)) {
 mtext(paste("Page",pagex),side=1,line=datex.line,adj=0.4,outer=T)
 page.counter <<- pagex + 1
 } else {
 mtext(paste("Page",page.counter),side=1,line=datex.line,adj=0.4,outer=T)
 page.counter <<- page.counter + 1
 }} 
if(!is.null(figx)) {
 figx.line <- line.count+11-(length(group.names))+2
 mtext(paste("Figure",figx),side=1,line=figx.line,adj=0.1,outer=T)
 }
return(d)
}


"%==%" <- 
function(a, b, nomatch=0, warn=T)
{
a <- as.character(a)
b <- as.character(b)
        if(warn)
        if(!all(as.logical(match(b, a, nomatch = 0)))) {
         warning("Right side has elements thant are not in the left side")
        }
        as.logical(match(a, b, nomatch = nomatch))
}

f.plot.survfit <- 
 function(x, conf.int, mark.time = T, mark = 3, col = 1, lty = 1, lwd = 1, cex
	 = 1, log = F, xscale = 1, yscale = 1, firstx = 0, firsty = 1, xmax,
	ymin = 0, fun, xlab = "", ylab = "", xaxs = NULL, ...)
{
	if(is.logical(log)) {
		logy <- log
		logx <- F
		if(logy)
			logax <- "y"
		else logax <- ""
	}
	else {
		logy <- (log == "y" || log == "xy")
		logx <- (log == "x" || log == "xy")
		logax <- log
	}
	if(!inherits(x, "survfit"))
		stop("First arg must be the result of survfit")
	if(missing(conf.int)) {
		if(is.null(x$strata) && !is.matrix(x$surv))
			conf.int <- T
		else conf.int <- F
	}
	if(is.null(x$strata)) {
		nstrat <- 1
		stemp <- rep(1, length(x$time))
	}
	else {
		nstrat <- length(x$strata)
		stemp <- rep(1:nstrat, x$strata)
	}
	ssurv <- x$surv
	stime <- x$time
	supper <- x$upper
	slower <- x$lower
	if(!missing(xmax) && any(x$time > xmax)) {
		# prune back the survival curves
		# I need to replace x's over the limit with xmax, and y's over the
		#  limit with either the prior y value or firsty
		keepx <- keepy <- NULL
		# lines to keep
		yzero <- NULL
		# if all points on a curve are < xmax
		tempn <- table(stemp)
		offset <- cumsum(c(0, tempn))
		for(i in 1:nstrat) {
			ttime <- stime[stemp == i]
			if(all(ttime <= xmax)) {
				keepx <- c(keepx, 1:tempn[i] + offset[i])
				keepy <- c(keepy, 1:tempn[i] + offset[i])
			}
			else {
				bad <- min((1:tempn[i])[ttime > xmax])
				if(bad == 1) {
					keepy <- c(keepy, 1 + offset[i])
					yzero <- c(yzero, 1 + offset[i])
				}
				else keepy <- c(keepy, c(1:(bad - 1), bad -
						1) + offset[i])
				keepx <- c(keepx, (1:bad) + offset[i])
				stime[bad + offset[i]] <- xmax
				x$n.event[bad + offset[i]] <- 1
			}
		}
		# ok, now actually prune it
		stime <- stime[keepx]
		stemp <- stemp[keepx]
		x$n.event <- x$n.event[keepx]
		if(is.matrix(ssurv)) {
			if(length(yzero))
				ssurv[yzero,  ] <- firsty
			ssurv <- ssurv[keepy,  , drop = F]
			if(!is.null(supper)) {
				if(length(yzero))
					supper[yzero,  ] <- slower[yzero,  ] <-
						firsty
				supper <- supper[keepy,  , drop = F]
				slower <- slower[keepy,  , drop = F]
			}
		}
		else {
			if(length(yzero))
				ssurv[yzero] <- firsty
			ssurv <- ssurv[keepy]
			if(!is.null(supper)) {
				if(length(yzero))
					supper[yzero] <- slower[yzero] <- 
						firsty
				supper <- supper[keepy]
				slower <- slower[keepy]
			}
		}
	}
	stime <- stime/xscale
	if(!missing(fun)) {
		if(is.character(fun)) {
			tfun <- switch(fun,
				log = function(x)
				x,
				event = function(x)
				1 - x,
				cumhaz = function(x) - log(x),
				cloglog = function(x)
				log( - log(x)),
				pct = function(x)
				x * 100,
				logpct = function(x)
				100 * x,
				stop("Unrecognized function argument"))
			if(fun == "log" || fun == "logpct")
				logy <- T
			if(fun == "cloglog") {
				logx <- T
				if(logy)
					logax <- "xy"
				else logax <- "x"
			}
		}
		else if(is.function(fun))
			tfun <- fun
		else stop("Invalid 'fun' argument")
		ssurv <- tfun(ssurv)
		if(!is.null(supper)) {
			supper <- tfun(supper)
			slower <- tfun(slower)
		}
		firsty <- tfun(firsty)
		ymin <- tfun(ymin)
	}
	if(is.null(x$n.event))
		mark.time <- F
	#expected survival curve
	# set default values for missing parameters
	if(is.matrix(ssurv)) ncurve <- nstrat * ncol(ssurv) else ncurve <- 
			nstrat
	mark <- rep(mark, length = ncurve)
	col <- rep(col, length = ncurve)
	lty <- rep(lty, length = ncurve)
	lwd <- rep(lwd, length = ncurve)
	if(is.numeric(mark.time))
		mark.time <- sort(mark.time[mark.time > 0])
	# Do axis range computations
	if(is.null(xaxs)) {
		#special x- axis style for survival curves
		xaxs <- "i"
		#what S thinks
		tempx <- max(stime) * 1.04
	}
	else tempx <- max(stime)
	tempx <- c(min(stime), tempx, firstx)
	if(logy) {
		tempy <- range(ssurv[is.finite(ssurv) & ssurv > 0])
		if(tempy[2] == 1)
			tempy[2] <- 0.99
		if(any(ssurv == 0)) {
			tempy[1] <- tempy[1] * 0.8
			ssurv[ssurv == 0] <- tempy[1]
			if(!is.null(supper)) {
				supper[supper == 0] <- tempy[1]
				slower[slower == 0] <- tempy[1]
			}
		}
		tempy <- c(tempy, firsty)
	}
	else tempy <- c(range(ssurv[is.finite(ssurv)]), firsty)
	if(missing(fun)) {
		tempx <- c(tempx, min(stime))
		tempy <- c(tempy, ymin)
	}
	#
	# Draw the basic box
	#
	plot(tempx, tempy * yscale, type = "n", log = logax, xlab = xlab, ylab
		 = ylab, xaxs = xaxs, ...)
	if(yscale != 1) {
		if(logy)
			par(usr = par("usr") - c(0, 0, log10(yscale), log10(
				yscale)))
		else par(usr = par("usr")/c(1, 1, yscale, yscale))
	}
	#
	# put up the curves one by one
	#   survfit has already put them into the "right" order
	dostep <- function(x, y)
	{
		if(is.na(x[1] + y[1])) {
			x <- x[-1]
			y <- y[-1]
		}
		n <- length(x)
		# replace verbose horizonal sequences like
		# (1, .2), (1.4, .2), (1.8, .2), (2.3, .2), (2.9, .2), (3, .1)
		# with (1, .2), (3, .1).  They are slow, and can smear the looks
		# of the line type.
		dupy <- c(T, diff(y[ - n]) != 0, T)
		n2 <- sum(dupy)
		#create a step function
		xrep <- rep(x[dupy], c(1, rep(2, n2 - 1)))
		yrep <- rep(y[dupy], c(rep(2, n2 - 1), 1))
		list(x = xrep, y = yrep)
	}
	i <- 0
	xend <- NULL
	yend <- NULL
	for(j in unique(stemp)) {
		who <- (stemp == j)
		xx <- c(firstx, stime[who])
		nn <- length(xx)
		deaths <- c(-1, x$n.event[who])
		if(is.matrix(ssurv)) {
			for(k in 1:ncol(ssurv)) {
				i <- i + 1
				yy <- c(firsty, ssurv[who, k])
				lines(dostep(xx, yy), lty = lty[i], col = col[
					i], lwd = lwd[i])
				if(is.numeric(mark.time)) {
					indx <- mark.time
					for(k in seq(along = mark.time))
						indx[k] <- sum(mark.time[k] >
							xx)
					points(mark.time[indx < nn], yy[indx[
						indx < nn]], pch = mark[i],
						col = col[i], cex = cex)
				}
				else if(mark.time == T && any(deaths == 0))
					points(xx[deaths == 0], yy[deaths ==
						0], pch = mark[i], col = col[
						i], cex = cex)
				xend <- c(xend, max(xx))
				yend <- c(yend, min(yy))
				if(conf.int == T && !is.null(supper)) {
					if(ncurve == 1)
						lty[i] <- lty[i] + 1
					yy <- c(firsty, supper[who, k])
					lines(dostep(xx, yy), lty = lty[i],
						col = col[i], lwd = lwd[i])
					yy <- c(firsty, slower[who, k])
					lines(dostep(xx, yy), lty = lty[i],
						col = col[i], lwd = lwd[i])
				}
			}
		}
		else {
			i <- i + 1
			yy <- c(firsty, ssurv[who])
			lines(dostep(xx, yy), lty = lty[i], col = col[i], lwd
				 = lwd[i])
			if(is.numeric(mark.time)) {
				indx <- mark.time
				for(k in seq(along = mark.time))
					indx[k] <- sum(mark.time[k] > xx)
				points(mark.time[indx < nn], yy[indx[indx <
					nn]], pch = mark[i], col = col[i],
					cex = cex)
			}
			else if(mark.time == T && any(deaths == 0))
				points(xx[deaths == 0], yy[deaths == 0], pch = 
					mark[i], col = col[i], cex = cex)
			xend <- c(xend, max(xx))
			yend <- c(yend, min(yy))
			if(conf.int == T && !is.null(supper)) {
				if(ncurve == 1)
					lty[i] <- lty[i] + 1
				yy <- c(firsty, supper[who])
				lines(dostep(xx, yy), lty = lty[i], col = col[
					i], lwd = lwd[i])
				yy <- c(firsty, slower[who])
				lines(dostep(xx, yy), lty = lty[i], col = col[
					i], lwd = lwd[i])
			}
		}
	}
	invisible(list(x = xend, y = yend))
}

f.plot.surv.fit <-
 function(surv, conf.int, mark.time = T, mark = 3, col = 1, lty = 1, lwd = 1, 
	na.strata = T, mark.cex = 1, log = F, yscale = 1, xlab = "Time", ylab =
	"Survival", xaxs = "e", ...)
{
	cnames <- match(c("time", "surv", "n.risk"), names(surv))
	if(any(is.na(cnames)))
		stop("`surv' must be the result of surv.fit")
	if(missing(conf.int)) {
		if(is.null(surv$strata))
			conf.int <- T
		else conf.int <- F
	}
	strata <- surv$strata
	if(is.null(strata))
		strata <- rep(1, length(surv$time))
	strata <- as.category(strata)
	strata[is.na(strata)] <- max(strata, na.rm = T) + 1
	ngroups <- length(unique(strata))	
	# set default values for missing parameters
	mark <- rep(mark, length = ngroups)
	col <- rep(col, length = ngroups)
	lty <- rep(lty, length = ngroups)
	lwd <- rep(lwd, length = ngroups)
	if(is.numeric(mark.time)) mark.time <- sort(mark.time[mark.time > 0])	#
# for log plots we have to be tricky about the y axis scaling
#
	if(log) {
		plot(c(0, max(surv$time)), yscale * c(0.99, min(0.1, surv$surv[
			surv$surv > 0], na.rm = T)), type = "n", log = "y", 
			xlab = xlab, ylab = ylab, xaxs = xaxs, ...)
	}
  else plot(c(0, max(surv$time)), yscale * c(0, 1), type = "n", xlab = 
			xlab, ylab = ylab, xaxs = xaxs, ...)
	if(yscale != 1) par(usr = par("usr")/c(1, 1, yscale, yscale))	#
# put up the curves one by one
#   surv.fit has already put them into the "right" order
	i <- 0
	xend <- NULL
	yend <- NULL
	for(j in unique(strata)) {
		i <- i + 1
		who <- (strata == j)	
	# next line identifies all of the 'step downs' or 'last point'
		drops <- (surv$n.event > 0 | surv$time == max(surv$time[who]))
		xx <- c(0, surv$time[who & drops])
		yy <- c(1, surv$surv[who & drops])
		lines(stepfun(xx, yy), lty = lty[i], col = col[i], lwd = lwd[i]
			)
		if(is.numeric(mark.time)) {
			nn <- length(xx)
			indx <- mark.time
			for(k in seq(along = mark.time))
				indx[k] <- sum(mark.time[k] > xx)
			points(mark.time[indx < nn], yy[indx[indx < nn]], pch
				 = mark[i], col = col[i], cex = mark.cex)
		}
		else if(mark.time == T & any(surv$n.event[who] == 0))
			points(surv$time[who & surv$n.event == 0], surv$surv[
				who & surv$n.event == 0], pch = mark[i], col = 
				col[i], cex = mark.cex)
		xend <- c(xend, max(xx))
		yend <- c(yend, min(yy))
		if(conf.int == T && !is.null(surv$upper)) {
			if(ngroups == 1)
				lty[i] <- lty[i] + 1
			yy <- c(1, surv$upper[who & drops])
			lines(stepfun(xx, yy), lty = lty[i], col = col[i])
			yy <- c(1, surv$lower[who & drops])
			lines(stepfun(xx, yy), lty = lty[i], col = col[i])
		}
	}
	print(list(x = xend, y = yend))
	invisible(list(x = xend, y = yend))
}



f.code <- function(x,label=attr(x,"label"),footnote=attr(x,"footnote"), 
 levels=attr(x,"levels"),labels=as.character(levels),exclude=NA)
{
label <- label
footnote <- footnote
levels <- levels
labels <- labels
if(!is.null(levels)) {
 x <- factor(x,levels=levels,exclude=exclude)
 levels(x) <- labels
}
attr(x,"label") <- label
attr(x,"footnote") <- footnote
return(x)
}


"f.round" <- 
function(x, digits = 0, miss="NA")
{
# function which rounds but keeps trailing zeros if necessary
fx <- as.vector(x)
fx <- ifelse(is.na(fx),miss,format(round(c(pi, fx), digits = digits))[-1])
attributes(fx) <- attributes(x)
return(fx)
}


f.round.pvalue <- function(pvalue,tex=T,digits=3,disp="P")
{
digits <- 3
if(digits==3) {
rpvalue <- if(pvalue<0.001) { if(tex) "$<$0.001" else "<0.001" } else {
    if(round(pvalue,3)<0.1) { format(round(pvalue,3))} else {
     format(round(pvalue,2))
}}
if (rpvalue=="1") rpvalue <- "1.00"
if (rpvalue=="0.1") rpvalue <- "0.10"
if (rpvalue=="0.2") rpvalue <- "0.20"
if (rpvalue=="0.3") rpvalue <- "0.30"
if (rpvalue=="0.4") rpvalue <- "0.40"
if (rpvalue=="0.5") rpvalue <- "0.50"
if (rpvalue=="0.6") rpvalue <- "0.60"
if (rpvalue=="0.7") rpvalue <- "0.70"
if (rpvalue=="0.8") rpvalue <- "0.80"
if (rpvalue=="0.9") rpvalue <- "0.90"

# if (rpvalue=="0.01") rpvalue <- "0.010"
# if (rpvalue=="0.02") rpvalue <- "0.020"
# if (rpvalue=="0.03") rpvalue <- "0.030"
# if (rpvalue=="0.04") rpvalue <- "0.040"
# if (rpvalue=="0.05") rpvalue <- "0.050"
# if (rpvalue=="0.06") rpvalue <- "0.060"
# if (rpvalue=="0.07") rpvalue <- "0.070"
# if (rpvalue=="0.08") rpvalue <- "0.080"
# if (rpvalue=="0.09") rpvalue <- "0.090"

rpvalue <- if(pvalue<0.001) paste(disp,rpvalue) else
 if(disp=="P") paste("P=",rpvalue,sep="") else paste(disp,rpvalue,sep="")
}
if(digits==4) {
rpvalue <- if(pvalue<0.0001) {if(tex) "P$<$0.0001" else "P<0.0001"} else {
    if(round(pvalue,4)<0.1) {paste("P=",format(round(pvalue,4)),sep="")} else {
    paste("P=",format(round(pvalue,3)),sep="")}}
if (rpvalue=="P=1") rpvalue <- "P=1.00"
if (rpvalue=="P=0.1") rpvalue <- "P=0.10"
if (rpvalue=="P=0.2") rpvalue <- "P=0.20"
if (rpvalue=="P=0.3") rpvalue <- "P=0.30"
if (rpvalue=="P=0.4") rpvalue <- "P=0.40"
if (rpvalue=="P=0.5") rpvalue <- "P=0.50"
if (rpvalue=="P=0.6") rpvalue <- "P=0.60"
if (rpvalue=="P=0.7") rpvalue <- "P=0.70"
if (rpvalue=="P=0.8") rpvalue <- "P=0.80"
if (rpvalue=="P=0.9") rpvalue <- "P=0.90"

if (rpvalue=="P=0.01") rpvalue <- "P=0.010"
if (rpvalue=="P=0.02") rpvalue <- "P=0.020"
if (rpvalue=="P=0.03") rpvalue <- "P=0.030"
if (rpvalue=="P=0.04") rpvalue <- "P=0.040"
if (rpvalue=="P=0.05") rpvalue <- "P=0.050"
if (rpvalue=="P=0.06") rpvalue <- "P=0.060"
if (rpvalue=="P=0.07") rpvalue <- "P=0.070"
if (rpvalue=="P=0.08") rpvalue <- "P=0.080"
if (rpvalue=="P=0.09") rpvalue <- "P=0.090"
}
return(list(pvalue=pvalue,rpvalue=rpvalue))
}
# figure out what to do with 0.999 where 1 is produced
# might want to get 1.00 or 1.0

# also what with 0.0999 which gives 0.1. should not it give 0.10?
# or 0.00999 which gives 0.01. should not it give 0.010?
# return(list(pvalue=pvalue,rpvalue= if(round(pvalue,3)<0.001) {
#     if(tex) "p$<$0.001" else "p<0.001"} else
#     paste("P=",format(signif(round(c(pvalue,pi-3),3),2))[1],sep="")))
